#!/usr/bin/env python

import re
import hashlib

import numpy as np

from snakemakelib_oliver.tools.fastq import FastqReader

class FastqSummary(object):
    def __init__(self, fname):
        # Set up default counts
        self.fname = fname
        self.numReads = 0
        self._readLenArray = []
        self._qualSet = set()

        self._header = []
        for read in FastqReader(fname):
            self.numReads += 1
            self.read = read
            self._readLenArray.append(len(read[1]))
            self._qualSet = self._qualSet.union(set(read[3]))
            self._header.append(read[0])

        # Parse the last header
        self._parseHeader(read[0])

        self.readLen = self._checkReadLen()
        self.score = self._checkReadQual()
        self.md5 = self._md5sum()

    def _checkReadLen(self):
        rmin = np.min(self._readLenArray)
        rmax = np.max(self._readLenArray)
        if rmin == rmax:
            return rmin
        else:
            return '{min}:{max}'.format(rmin, rmax)

    def _checkReadQual(self):
        """
        https://en.wikipedia.org/wiki/FASTQ_format

          SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS.....................................................
          ..........................XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX......................
          ...............................IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII......................
          .................................JJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJ......................
          LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL....................................................
          !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
          |                         |    |        |                              |                     |
         33                        59   64       73                            104                   126
          0........................26...31.......40                                
                                   -5....0........9.............................40 
                                         0........9.............................40 
                                            3.....9.............................40 
          0.2......................26...31........41                              

         S - Sanger        Phred+33,  raw reads typically (0, 40)
         X - Solexa        Solexa+64, raw reads typically (-5, 40)
         I - Illumina 1.3+ Phred+64,  raw reads typically (0, 40)
         J - Illumina 1.5+ Phred+64,  raw reads typically (3, 40)
             with 0=unused, 1=unused, 2=Read Segment Quality Control Indicator (bold) 
             (Note: See discussion above).
         L - Illumina 1.8+ Phred+33,  raw reads typically (0, 41)

        """

        values = np.array([ord(x) for x in self._qualSet])
        v = (np.min(values), np.max(values))

        # Remember python ranges don't include last number so you have to add 1

        # Sanger (0, 40) aka (33, 73)
        if v[0] in range(33, 73+1) and v[1] in range(33, 74+1):
            score = 'Phred+33 (Sanger)'

        # Illumina 1.8+ (0, 41) aka (33, 74)
        elif v[0] in range(0, 41+1) and v[1] in range(0, 41+1):
            score = 'Phred+33 (Illumina 1.8+)'
        
        # Illumina 1.5+ (3, 40) aka (67, 104)
        elif v[0] in range(67, 104+1) and v[1] in range(67, 104+1):
            score = 'Phred+64 (Illumina 1.5+)'

        # Illumina 1.3+ (0, 40) aka (64, 104)
        elif v[0] in range(64, 104+1) and v[1] in range(64, 104+1):
            score = 'Phred+64 (Illumina 1.3+)'
            
        # Solexa (-5, 40) aka (59, 104)
        elif v[0] in range(59, 104+1) and v[1] in range(59, 104+1):
            score = 'Phred+64 (Solexa)'

        else:
            score = 'ERROR: Check Qualtiy Scores'

        return score

    def _parseHeader(self, header):
        """
        https://en.wikipedia.org/wiki/FASTQ_format
        """ 
        self.instrument = ''
        self.runID = ''
        self.flowcellID = ''
        self.lane = ''
        self.pair = ''
        self.bc = ''

        spaceCount = re.findall(' ', header.strip())

        if len(spaceCount) == 0:
            # Pre CASAVA 1.8
            # @HWUSI-EAS100R:6:73:941:1973#0/1
            pattern = '(\@.*?):(\d+):\d+:\d+:\d+\#(.*)\/(\d)'

            m = re.match(pattern, header)
            self.instrument = m.groups()[0]
            self.lane = m.groups()[1]
            self.bc = m.groups()[2]
            self.pair = m.groups()[3]

        elif len(spaceCount) == 1:
            # CASAVA 1.8
            # @EAS139:136:FC706VJ:2:2104:15343:197393 1:Y:18:ATCACG
            pattern = '(\@.*?):(\d+):(.*?):(\d+):\d+:\d+:\d+ (\d):[Y,N]:\d+:(.*)'

            m = re.match(pattern, header)
            self.instrument = m.groups()[0]
            self.runID = m.groups()[1]
            self.flowcellID = m.groups()[2]
            self.lane = m.groups()[3]
            self.pair = m.groups()[4]
            self.bc = m.groups()[5]

        elif len(spaceCount) > 1:
            # Probably SRA
            # @SRR001666.1 071112_SLXA-EAS1_s_7:5:1:817:345 length=36
            #TODO: look at a bunch of SRAs and figure out pattern
            pattern = '(\@.*?) .*?'
            self.instrument = "WARN: SRA parsing is not implemented"
        else:
            self.instrument = "ERROR: header is strange"

    def _md5sum(self):
        with open(self.fname, 'rb') as IN:
            md5 = hashlib.md5(IN.read()).hexdigest()
        return md5

rule summariesFq:
    input: '/Users/fearjm/tmp/fq/DamIDseq_1_151020_run0437.fastq.gz'
    run:
        bob = FastqSummary(fname)
        dir(bob)
